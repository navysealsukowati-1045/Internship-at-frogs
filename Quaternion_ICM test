import numpy as np
import time
from smbus2 import SMBus
import matplotlib.pyplot as plt

# ICM-20948 I2C Address
ICM20948_ADDR = 0x69

# Register Addresses
REG_BANK_SEL = 0x7F
PWR_MGMT_1 = 0x06
ACCEL_XOUT_H = 0x2D
GYRO_XOUT_H = 0x33
MAG_XOUT_L = 0x11
ACCEL_CONFIG = 0x14
GYRO_CONFIG_1 = 0x01

# Sensitivity Scale Factors (sesuai datasheet ICM-20948)
# Accelerometer: ±2g → 16,384 LSB/g
ACCEL_SENSITIVITY = 16384.0  # LSB/g

# Gyroscope: ±250 dps → 131 LSB/(°/s)
GYRO_SENSITIVITY = 131.0  # LSB/(°/s)

# Magnetometer: ±4900 µT → 0.15 µT/LSB
MAG_SENSITIVITY = 0.15  # µT/LSB

class ICM20948:
    def __init__(self, bus_num=1):
        self.bus = SMBus(bus_num)
        self.addr = ICM20948_ADDR
        self.initialize()
        
    def write_register(self, bank, reg, value):
        """Write to register with bank selection"""
        # Select bank
        self.bus.write_byte_data(self.addr, REG_BANK_SEL, bank << 4)
        # Write register
        self.bus.write_byte_data(self.addr, reg, value)
        
    def read_registers(self, bank, reg, length):
        """Read multiple registers"""
        self.bus.write_byte_data(self.addr, REG_BANK_SEL, bank << 4)
        return self.bus.read_i2c_block_data(self.addr, reg, length)
    
    def initialize(self):
        """Initialize ICM-20948"""
        # Reset device
        self.write_register(0, PWR_MGMT_1, 0x80)
        time.sleep(0.1)
        
        # Auto select clock source
        self.write_register(0, PWR_MGMT_1, 0x01)
        time.sleep(0.01)
        
        # Configure Gyroscope (±250 dps)
        self.write_register(2, GYRO_CONFIG_1, 0x00)
        
        # Configure Accelerometer (±2g)
        self.write_register(2, ACCEL_CONFIG, 0x00)
        
        print("ICM-20948 initialized")
        print(f"Accel sensitivity: {ACCEL_SENSITIVITY} LSB/g")
        print(f"Gyro sensitivity: {GYRO_SENSITIVITY} LSB/(°/s)")
        print(f"Mag sensitivity: {MAG_SENSITIVITY} µT/LSB")
        
    def read_accel(self):
        """Read accelerometer data (x, y, z) dalam g"""
        data = self.read_registers(0, ACCEL_XOUT_H, 6)
        
        # Convert to signed 16-bit
        ax_raw = np.int16((data[0] << 8) | data[1])
        ay_raw = np.int16((data[2] << 8) | data[3])
        az_raw = np.int16((data[4] << 8) | data[5])
        
        # Convert ke besaran fisik (g)
        ax = ax_raw / ACCEL_SENSITIVITY
        ay = ay_raw / ACCEL_SENSITIVITY
        az = az_raw / ACCEL_SENSITIVITY
        
        return np.array([ax, ay, az])
    
    def read_gyro(self):
        """Read gyroscope data (x, y, z) dalam rad/s"""
        data = self.read_registers(0, GYRO_XOUT_H, 6)
        
        # Convert to signed 16-bit
        gx_raw = np.int16((data[0] << 8) | data[1])
        gy_raw = np.int16((data[2] << 8) | data[3])
        gz_raw = np.int16((data[4] << 8) | data[5])
        
        # Convert ke besaran fisik (°/s → rad/s)
        gx = np.deg2rad(gx_raw / GYRO_SENSITIVITY)
        gy = np.deg2rad(gy_raw / GYRO_SENSITIVITY)
        gz = np.deg2rad(gz_raw / GYRO_SENSITIVITY)
        
        return np.array([gx, gy, gz])
    
    def read_mag(self):
        """Read magnetometer data (x, y, z) dalam µT"""
        # Magnetometer berada di bank 0, tapi perlu enable dulu
        # Ini simplified version, real implementation butuh AK09916 setup
        data = self.read_registers(0, MAG_XOUT_L, 6)
        
        # Convert to signed 16-bit (little endian untuk mag)
        mx_raw = np.int16((data[1] << 8) | data[0])
        my_raw = np.int16((data[3] << 8) | data[2])
        mz_raw = np.int16((data[5] << 8) | data[4])
        
        # Convert ke besaran fisik (µT)
        mx = mx_raw * MAG_SENSITIVITY
        my = my_raw * MAG_SENSITIVITY
        mz = mz_raw * MAG_SENSITIVITY
        
        return np.array([mx, my, mz])

class QuaternionFilter:
    def __init__(self, beta=0.1):
        self.q = np.array([1.0, 0.0, 0.0, 0.0])  # w, x, y, z
        self.beta = beta  # Madgwick filter gain
        
    def madgwick_update(self, gyro, accel, mag, dt):
        """
        Update quaternion menggunakan algoritma Madgwick 9DOF
        gyro: [gx, gy, gz] dalam rad/s
        accel: [ax, ay, az] dalam g
        mag: [mx, my, mz] dalam µT
        dt: delta time dalam detik
        """
        q = self.q
        gx, gy, gz = gyro
        ax, ay, az = accel
        mx, my, mz = mag
        
        # Normalize accelerometer
        norm = np.sqrt(ax**2 + ay**2 + az**2)
        if norm == 0:
            return
        ax, ay, az = ax/norm, ay/norm, az/norm
        
        # Normalize magnetometer
        norm = np.sqrt(mx**2 + my**2 + mz**2)
        if norm == 0:
            return
        mx, my, mz = mx/norm, my/norm, mz/norm
        
        # Auxiliary variables
        q0, q1, q2, q3 = q
        _2q0, _2q1, _2q2, _2q3 = 2*q0, 2*q1, 2*q2, 2*q3
        q0q0, q1q1, q2q2, q3q3 = q0**2, q1**2, q2**2, q3**2
        
        # Reference direction of Earth's magnetic field
        hx = 2*mx*(0.5 - q2q2 - q3q3) + 2*my*(q1*q2 - q0*q3) + 2*mz*(q1*q3 + q0*q2)
        hy = 2*mx*(q1*q2 + q0*q3) + 2*my*(0.5 - q1q1 - q3q3) + 2*mz*(q2*q3 - q0*q1)
        bx = np.sqrt(hx**2 + hy**2)
        bz = 2*mx*(q1*q3 - q0*q2) + 2*my*(q2*q3 + q0*q1) + 2*mz*(0.5 - q1q1 - q2q2)
        
        # Gradient descent algorithm
        s0 = -_2q2*(2*(q1*q3 - q0*q2) - ax) + _2q1*(2*(q0*q1 + q2*q3) - ay) \
             - bz*q2*(_2bx*(0.5 - q2q2 - q3q3) + _2bz*(q1*q3 - q0*q2) - mx) \
             + (-_2bx*q3 + _2bz*q1)*(_2bx*(q1*q2 - q0*q3) + _2bz*(q0*q1 + q2*q3) - my) \
             + _2bx*q2*(_2bx*(q0*q2 + q1*q3) + _2bz*(0.5 - q1q1 - q2q2) - mz)
        
        s1 = _2q3*(2*(q1*q3 - q0*q2) - ax) + _2q0*(2*(q0*q1 + q2*q3) - ay) \
             - 4*q1*(1 - 2*(q1q1 + q2q2) - az) + _2bz*q3*(_2bx*(0.5 - q2q2 - q3q3) + _2bz*(q1*q3 - q0*q2) - mx) \
             + (_2bx*q2 + _2bz*q0)*(_2bx*(q1*q2 - q0*q3) + _2bz*(q0*q1 + q2*q3) - my) \
             + (_2bx*q3 - 4*bz*q1)*(_2bx*(q0*q2 + q1*q3) + _2bz*(0.5 - q1q1 - q2q2) - mz)
        
        s2 = -_2q0*(2*(q1*q3 - q0*q2) - ax) + _2q3*(2*(q0*q1 + q2*q3) - ay) \
             - 4*q2*(1 - 2*(q1q1 + q2q2) - az) + (-4*bx*q2 - _2bz*q0)*(_2bx*(0.5 - q2q2 - q3q3) + _2bz*(q1*q3 - q0*q2) - mx) \
             + (_2bx*q1 + _2bz*q3)*(_2bx*(q1*q2 - q0*q3) + _2bz*(q0*q1 + q2*q3) - my) \
             + (_2bx*q0 - 4*bz*q2)*(_2bx*(q0*q2 + q1*q3) + _2bz*(0.5 - q1q1 - q2q2) - mz)
        
        s3 = _2q1*(2*(q1*q3 - q0*q2) - ax) + _2q2*(2*(q0*q1 + q2*q3) - ay) \
             + (-4*bx*q3 + _2bz*q1)*(_2bx*(0.5 - q2q2 - q3q3) + _2bz*(q1*q3 - q0*q2) - mx) \
             + (-_2bx*q0 + _2bz*q2)*(_2bx*(q1*q2 - q0*q3) + _2bz*(q0*q1 + q2*q3) - my) \
             + _2bx*q1*(_2bx*(q0*q2 + q1*q3) + _2bz*(0.5 - q1q1 - q2q2) - mz)
        
        # Normalize gradient
        norm = np.sqrt(s0**2 + s1**2 + s2**2 + s3**2)
        if norm > 0:
            s0, s1, s2, s3 = s0/norm, s1/norm, s2/norm, s3/norm
        
        # Rate of change of quaternion
        qDot0 = 0.5*(-q1*gx - q2*gy - q3*gz) - self.beta*s0
        qDot1 = 0.5*(q0*gx + q2*gz - q3*gy) - self.beta*s1
        qDot2 = 0.5*(q0*gy - q1*gz + q3*gx) - self.beta*s2
        qDot3 = 0.5*(q0*gz + q1*gy - q2*gx) - self.beta*s3
        
        # Integrate
        q0 += qDot0 * dt
        q1 += qDot1 * dt
        q2 += qDot2 * dt
        q3 += qDot3 * dt
        
        # Normalize quaternion
        norm = np.sqrt(q0**2 + q1**2 + q2**2 + q3**2)
        self.q = np.array([q0, q1, q2, q3]) / norm
        
    def get_euler(self):
        """Convert quaternion to Euler angles (roll, pitch, yaw) dalam derajat"""
        q0, q1, q2, q3 = self.q
        
        # Roll (A - rotation about X-axis)
        roll = np.arctan2(2*(q0*q1 + q2*q3), 1 - 2*(q1**2 + q2**2))
        
        # Pitch (B - rotation about Y-axis)
        sinp = 2*(q0*q2 - q3*q1)
        if abs(sinp) >= 1:
            pitch = np.copysign(np.pi/2, sinp)
        else:
            pitch = np.arcsin(sinp)
        
        # Yaw (C - rotation about Z-axis)
        yaw = np.arctan2(2*(q0*q3 + q1*q2), 1 - 2*(q2**2 + q3**2))
        
        return np.rad2deg([roll, pitch, yaw])

def calculate_rmse(errors):
    """Calculate Root Mean Square Error"""
    return np.sqrt(np.mean(np.array(errors)**2))

def calculate_itae(errors, times):
    """Calculate Integral of Time-weighted Absolute Error"""
    errors = np.array(errors)
    times = np.array(times)
    return np.trapz(times * np.abs(errors), times)

def main():
    # Simulasi data (karena tidak ada hardware real)
    # Dalam implementasi real, gunakan: sensor = ICM20948()
    
    print("="*60)
    print("Quaternion 9DOF IMU ICM-20948 dengan RMSE dan ITAE")
    print("="*60)
    print()
    
    # Initialize filter
    qfilter = QuaternionFilter(beta=0.1)
    
    # Storage untuk analisis
    quaternions = []
    euler_angles = []
    timestamps = []
    errors_roll = []
    errors_pitch = []
    errors_yaw = []
    
    # Ground truth (referensi) untuk error calculation
    true_roll, true_pitch, true_yaw = 0, 0, 0
    
    # Simulasi 100 sampel data
    dt = 0.01  # 100 Hz
    duration = 1.0  # 1 detik
    samples = int(duration / dt)
    
    print(f"Mengambil {samples} sampel data dengan rate {1/dt} Hz...")
    print()
    
    for i in range(samples):
        t = i * dt
        
        # Simulasi data sensor (dalam implementasi real, baca dari sensor)
        accel = np.array([0.0, 0.0, 1.0])  # 1g gravitasi
        gyro = np.array([0.1, 0.05, 0.02])  # rad/s
        mag = np.array([25.0, 0.0, 40.0])  # µT (contoh medan magnet)
        
        # Update quaternion
        qfilter.madgwick_update(gyro, accel, mag, dt)
        
        # Get Euler angles
        roll, pitch, yaw = qfilter.get_euler()
        
        # Store data
        quaternions.append(qfilter.q.copy())
        euler_angles.append([roll, pitch, yaw])
        timestamps.append(t)
        
        # Calculate errors (dibandingkan dengan ground truth)
        errors_roll.append(roll - true_roll)
        errors_pitch.append(pitch - true_pitch)
        errors_yaw.append(yaw - true_yaw)
        
        # Print setiap 10 sampel
        if i % 10 == 0:
            print(f"t={t:.2f}s | Q: [{qfilter.q[0]:.3f}, {qfilter.q[1]:.3f}, "
                  f"{qfilter.q[2]:.3f}, {qfilter.q[3]:.3f}]")
            print(f"       | Euler (A,B,C,D): Roll={roll:.2f}°, Pitch={pitch:.2f}°, "
                  f"Yaw={yaw:.2f}°, Heading={yaw:.2f}°")
            print()
    
    # Calculate metrics
    print("="*60)
    print("ANALISIS ERROR")
    print("="*60)
    
    rmse_roll = calculate_rmse(errors_roll)
    rmse_pitch = calculate_rmse(errors_pitch)
    rmse_yaw = calculate_rmse(errors_yaw)
    
    itae_roll = calculate_itae(errors_roll, timestamps)
    itae_pitch = calculate_itae(errors_pitch, timestamps)
    itae_yaw = calculate_itae(errors_yaw, timestamps)
    
    print(f"\nRoot Mean Square Error (RMSE):")
    print(f"  Roll (A):  {rmse_roll:.4f}°")
    print(f"  Pitch (B): {rmse_pitch:.4f}°")
    print(f"  Yaw (C):   {rmse_yaw:.4f}°")
    
    print(f"\nIntegral Time Absolute Error (ITAE):")
    print(f"  Roll (A):  {itae_roll:.4f} °·s")
    print(f"  Pitch (B): {itae_pitch:.4f} °·s")
    print(f"  Yaw (C):   {itae_yaw:.4f} °·s")
    
    print(f"\nTotal RMSE: {np.sqrt(rmse_roll**2 + rmse_pitch**2 + rmse_yaw**2):.4f}°")
    print(f"Total ITAE: {itae_roll + itae_pitch + itae_yaw:.4f} °·s")
    
    # Plot hasil
    plot_results(timestamps, euler_angles, errors_roll, errors_pitch, errors_yaw)

def plot_results(times, euler, err_roll, err_pitch, err_yaw):
    """Plot Euler angles dan errors"""
    euler = np.array(euler)
    
    fig, axes = plt.subplots(2, 1, figsize=(12, 8))
    
    # Plot Euler angles
    axes[0].plot(times, euler[:, 0], label='Roll (A)', linewidth=2)
    axes[0].plot(times, euler[:, 1], label='Pitch (B)', linewidth=2)
    axes[0].plot(times, euler[:, 2], label='Yaw (C)', linewidth=2)
    axes[0].set_xlabel('Time (s)')
    axes[0].set_ylabel('Angle (°)')
    axes[0].set_title('Euler Angles from Quaternion (9DOF)')
    axes[0].legend()
    axes[0].grid(True)
    
    # Plot errors
    axes[1].plot(times, err_roll, label='Roll Error', linewidth=2)
    axes[1].plot(times, err_pitch, label='Pitch Error', linewidth=2)
    axes[1].plot(times, err_yaw, label='Yaw Error', linewidth=2)
    axes[1].set_xlabel('Time (s)')
    axes[1].set_ylabel('Error (°)')
    axes[1].set_title('Estimation Errors')
    axes[1].legend()
    axes[1].grid(True)
    
    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    main()
